# 操作系统

>回答这部分的时候要注意回答的深入，比如进程线程区别、同步（通信）的方式，共享内存、信号、信号量、各种锁。从原理回答、历史来源、改进方法、源代码，一层一层递进的讲出这些设计的本质，这样比较好，面试官喜欢。

>源代码：重点部分在文件系统、进程管理、进程切换、内存管理等几个部分。其中文件管理和内存管理很重要。包括vfs虚拟文件系统。一个完整的文件操作过程（read\write）,文件映射mmap，共享内存等等。

# 内容
### 1、进程和线程的区别


- 进程概念

  进程是表示资源分配的基本单位，又是调度运行的基本单位。例如，用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘 空间、I／O设备等。然后，把该进程放人进程的就绪队列。进程调度程序选中它，为它分配CPU以及其它有关资源，该进程才真正运行。所以，进程是系统中的 并发执行的单位。 
在Mac、Windows NT等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。

- 线程概念

  线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把进程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。例如，假 设用户启动了一个窗口中的数据库应用程序，操作系统就将对数据库的调用表示为一个进程。假设用户要从数据库中产生一份工资单报表，并传到一个文件中，这是 一个子任务；在产生工资单报表的过程中，用户又可以输人数据库查询请求，这又是一个子任务。这样，操作系统则把每一个请求――工资单报表和新输人的数据查 询表示为数据库进程中的独立的线程。
线程可以在处理器上独立调度执行，这样，在多处理器环境下就允许几个线程各自在单独处理器上进行。操作系统提供线程就是为了方便而有效地实现这种并发性。


  
  （1）进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元
  
  （2）同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。
  
  （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束
  
  （4）线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的
  
  （5）线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源
  
  （6）线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志
  
  （7）进程的退出时exit,线程的退出是pthread_exit

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一 个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。


- 引入线程的好处 

  （1）易于调度。 
  
  （2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。 
  
  （3）开销少。创建线程比创建进程要快，所需开销很少。
  
  （4）利于充分发挥多处理器的功能。通过创建多线程进程（即一个进程可具有两个或更多个线程），每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。 

但是对linux操作系统来说，调度解决的对象是线程而不是进程，很大一部分原因在于linux认为线程和进程是一样的。

### 2、进程和线程私有和共享的资源

- 线程共享的环境包括：

  1.进程代码段 
  
  2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) 
  
  3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。

- 线程独立的资源包括：

  线程私有的资源必须包含寄存器，否则错误

  - 1.线程ID
    
    每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。
  
  - 2.寄存器组的值
    
    由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。
  
  - 3.线程的堆栈
    
    堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。
  
  - 4.错误返回码
    
    由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。

  - 5.线程的信号屏蔽码
    
    由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都 共享同样的信号处理器。

  - 6.线程的优先级
    
    由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。

  - 使用资源：

    唯一使用的资源是内核栈和上下文切换时保持寄存器的空间

    每个线程都有自己的执行堆栈，程序计数器，通用寄存器组和状态标记

    线程栈空间是开辟在进程堆区域的，不是开辟在进程栈空间内的！


### 3、Fork创建进程后全局变量、静态变量、全局静态变量、堆中的对象、栈变量共享吗?

都不能共享的。在fork创建多进程之后堆栈信息会完全复制给子进程内存空间，父子进程相互独立。vfork创建的进程由于子进程共享父进程的地址空间，所以子进程修改变量对于父进程是可见的，并且保证子进程先运行，只有exec或者exit止之后父进程才会被调度。
当调用fork函数后，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，所以是一个完整的进程。为了给这个新进程创建虚拟存储器，它创建了当前进程的mm_struct,区域结构和页表的原样拷贝,然后把两个进程的每个页面都标记为只读,并将两个进程中的每个区域结构都标记为私有的写时拷贝.进程进行写操作时,写时拷贝机制就会创建新页面.
(同一进程下的线程共享全局变量、静态变量)

### 4、Fork()与vfork()的区别？

fork：通过写时拷贝机制创建子进程。子进程通过拷贝父进程的页表与父进程共享相同的物理内存(被标记为只读)，当其中一方试图修改物理内存上的数据时发生中断，内核拷贝被修改页并修改子进程的页表使其指向新拷贝的一页，之后对该页上的数据进行修改不再产生中断。因此可以理解成父进程和子进程拥有独立的地址空间而相互不干扰。这是一种写时拷贝技术，可以提高fork效率。
子进程会复制父进程的task_struct结构，并为子进程的堆栈分配物理页。理论上来说，子进程应该完整地复制父进程的堆，栈以及数据空间，但是2者共享正文段。

vfork：vfork之后，子进程先运行，当子进程调用exec或者exit后运行父进程。子进程和父进程共享地址空间，因此不论在父进程还是子进程中对数据的修改另一方是可见的。vfork设计是用来执行新程序的，即vfork后子进程马上调用exec系列函数。

- 区别：
  
  - 1、fork出来的父子进程交替运行，vfork出来的进程是父进程阻塞，直到子进程结束。
  - 2、fork实现了写时拷贝，vfork就算是写，也不拷贝。
  - 3、vfork必须使用exit或者exec后父进程才会运行。
  - 4、我们就算是把fork实现了写时拷贝，它的性能也没有vfork高。
  - 5、每个系统是的vfork都有问题，不建议使用。

### 5、进程创建的过程（底层调用）

  （1）为新进程在进程表中分配一个表项
  
  （2）为子进程赋一个唯一的进程标识符
  
  （3）做一个父进程上下文的逻辑副本，不包括共享内存区
  
  （4）增加父进程所拥有所有文件的计数器，以表示有一个另外的进程现在也拥有这些文件
  
  （5）把子进程设置为就绪态
  
  （6）向父进程返回子进程的进程号，对子进程返回0

### 6、一个32位机器上linux进程最大可以申请多少空间

- 4G空间，其中3G的空间为用户空间，1G的空间为内核空间

  补充：为什么设计为3G和1G，这个腾讯TEG面试经理问过我。

### 7、32位系统中一个进程最多可以有多少堆内存

- 没有上限，直到碰到堆的上限为止

### 8、多线程和多进程的区别？（重点。面试官最最关心的一个问题，从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答）
 
### 9、什么时候采用多进程，什么时候采用多线程

- 需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大）

- 需要进行大量计算的优先使用线程（CPU频繁切换）

- 可能要扩展到多机分布的用进程，多核分布的用线程

### 10、如何创建动态库、静态库

静态库（.a、.lib）和动态库（.so、.dll）

- 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。

- 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。

  补充：如何生成动态库静态库？

### 11、静态链接和动态链接的区别

- 动态链接是指在生成可执行文件时不将所有程序用到的函数链接到一个文件，因为有许多函数在操作系统带的dll文件中，当程序运行时直接从操作系统中找。而静态链接就是把所有用到的函数全部链接到exe文件中。

- 动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入;而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了。

### 12、守护进程、僵尸进程、孤儿进程
- 守护进程：
	
  守护进程也叫做精灵进程，它的主要目的还是为了创建后台进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述符，控制终端，会话和进程组，工作目录以及文件创建掩模等。这些环境通常是守护进程从执行它的父进程(特别是shell)中继承下来的。最后，守护进程的启动方式有其特殊之处。它可以在Linux系统启动时从启动脚本/etc/rc.d中启动，可以由作业规划进程crond启动，还可以由用户终端(shell)执行。
  
  编写：
    
    （1）后台运行：父进程exit退出，子进程继续
    
    （2）脱离控制终端、登陆会话、进程组：调用etsid()使进程成为会话组长（这三个都是从父进程中继承下来的。由于会话过程对于控制终端的独占性，所以控制终端也脱离）
    
    （3）禁止进程重写打开控制终端。此时再fork()
    
    （4）关闭打开的文件描述符，防止资源的浪费。for(i=0;i 关闭打开的文件描述符close(i);)
    
    （5）改变当前工作目录为根目录。防止中间某个目录被删除运行不了。
    
    （6）为了防止守护进程所创建的文件权限混乱，此时umask(0)
    
    （7）处理SIGCHILD信号。signal(SIGCHLD,SIG_IGN);此时内核在子进程结束不会产生僵尸进程。

- 僵尸进程：
	一个进程如果创建出子进程，如果此时子进程退出，而父进程没有进行善后工作（wait与waitpid获取子进程状态信息），那么此时子进程的进程描述符仍然保存在系统中。此时子进程就是僵尸进程。
  
  处理方法：
  
  - 1、信号signal(SIGCHLD, sig_child); 信号处理函数处理
  ```
  static void sig_child(int signo)
  {
      pid_t pid;
      int stat;
      while ((pid = waitpid(-1, &stat, WNOHANG)) > 0)
          printf("child %d terminated.\n", pid);
  }
  ```

  - 2、fork两次
      让父进程去等，子进程继续fork
- 孤儿进程：
	
  如果父进程退出，子进程还在，此时子进程就是孤儿进程。但是孤儿进程会被1号进程收养，1号进程也叫做init进程，所以不会产生内存泄漏问题。

### 13、进程间通信
  
  （1）管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
  
  （2）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于 BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
  
  （3）消息队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
  
  （4）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
  
  （5）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
  
  （6）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

### 14、管道
- 匿名管道
  
  匿名管道：不能在系统的文件管理中找到相应管道所在的文件  
  
  具体步骤为：
  
  （1）父进程调用pipe开辟管道，得到两个文件描述符指向文件的两端 
  
  （2）父进程调用fork创建子进程，子进程也产生两个文件描述符指向文件的两端。 
  
  （3）由于管道只能实现单向通信，因此需要父子进程需要关闭适当的读写端。父进程关闭读端，子进程关闭写端，就像上图中看到的，父进程可以往管道里写，子进程可以从管道里读，管道使用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。
 
  - 匿名管道的特点： 
    
    （1）只能实现单向通信 
    
    （2）只能用于具有血缘关系的进程之间进行通信，通常用于父子进程。 
    
    （3）不会读到错误和乱码，因为管道自带同步机制 
    
    （4）管道在进行通信的时候，对外界提供的服务是面向字节流的 
    
    （5）管道是依赖于文件系统的，他的生命周期随进程，（即进程退出，则管道消失）,

- 命名管道
  
  命名管道由mkfifo函数创建。打开用open

### 15、共享内存原理
**必考必问，然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置?共享内存段最大限制是多少?**

**最大限制在/proc/sys/kernel/more shmmax可以查看**

- 共享内存定义：

  共享内存是最快的可用IPC(进程间通信)形式。它允许多个不相关的进程去访问同一部分逻辑内存。共享内存是由IPC为一个进程创建的一个特殊的地址范围，它将出现在进程的地址空间中。其他进程可以把同一段共享内存段“连接到”它们自己的地址空间里去（通过页表、MMU映射这个要讲出来）。所有进程都可以访问共享内存中的地址。如果一个进程向这段共享内存写了数据，所做的改动会立刻被有访问同一段共享内存的其他进程看到。因此共享内存对于数据的传输是非常高效的。

- 共享内存的原理：

  共享内存是最有用的进程间通信方式之一，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。
### 16、exit()与_exit()的区别?

- _exit 函数的作用是：直接使进程停止运行，清除其使用的内存空间，并清除其在内核的各种数据结构；
  
- exit 函数则在这些基础上做了一些小动作，在执行退出之前还加了若干道工序。

- exit() 函数与 _exit() 函数的最大区别在于exit()函数在调用exit系统调用前要检查文件的打开情况，把文件缓冲区中的内容写回文件。也就是“清理I/O缓冲”。

### 17、常见信号，信号怎么处理的?
- 忽略信号

- 捕捉信号

- 执行系统的默认处理动作

### 18、IO阻塞和非阻塞、同步异步如何理解

在等待数据阶段，IO分为阻塞IO和非阻塞IO。
  
  （1）阻塞IO： 资源不可用时，IO请求一直阻塞，直到反馈结果（有数据或超时）。
  
  （2）非阻塞IO：资源不可用时，IO请求离开返回，返回数据标识资源不可用

在使用资源阶段，IO分为同步IO和异步IO。
  
  （1）同步IO：应用阻塞在发送或接收数据的状态，直到数据成功传输或返回失败。
  
  （2）异步IO：应用发送或接收数据后立刻返回，数据写入OS缓存，由OS完成数据发送或接收，并返回成功或失败的信息给应用。

### 19、Linux下各类同步机制?(重点！！)

- 线程同步机制：
  
  互斥锁是pthread_mutex_t、条件变量pthread_cond_t cond、信号量sem_init

- 进程同步机制：

  信号量集

- 互斥锁

  - 1、初始化锁。在Linux下，线程的互斥量数据类型是pthread_mutex_t。在使用前,要对它进行初始化。
    
      静态分配：pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    
      动态分配：int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutex_attr_t *mutexattr);

  - 2、加锁。对共享资源的访问，要对互斥量进行加锁，如果互斥量已经上了锁，调用线程会阻塞，直到互斥量被解锁。
      
      int pthread_mutex_lock(pthread_mutex *mutex);
      
      int pthread_mutex_trylock(pthread_mutex_t *mutex);
  
  - 3、解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。
    
    int pthread_mutex_unlock(pthread_mutex_t *mutex);
  
  - 4、销毁锁。锁在是使用完成后，需要进行销毁以释放资源。
    
    int pthread_mutex_destroy(pthread_mutex *mutex);

- 条件变量：

  互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。条件变量分为两部分:条件和变量。条件本身是由互斥量保护的。线程在改变条件状态前先要锁住互斥量。条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待"条件变量的条件成立"而挂起；另一个线程使"条件成立"（给出条件成立信号）。条件的检测是在互斥锁的保护下进行的。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。

  - 1、初始化条件变量。
    
    静态态初始化，pthread_cond_t cond = PTHREAD_COND_INITIALIER;
    
    动态初始化，int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);
  
  - 2、等待条件成立。释放锁,同时阻塞等待条件变量为真才行。timewait()设置等待时间,仍未signal,返回ETIMEOUT(加锁保证只有一个线程wait)
   
    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
    
    int pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime);
  
  - 3、激活条件变量。pthread_cond_signal,pthread_cond_broadcast（激活所有等待线程）
    
    int pthread_cond_signal(pthread_cond_t *cond);
    
    int pthread_cond_broadcast(pthread_cond_t *cond); //解除所有线程的阻塞
  
  - 4、清除条件变量。无线程等待,否则返回EBUSY
    
    int pthread_cond_destroy(pthread_cond_t *cond);

- 信号量：
  
  如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。信号量函数的名字都以"sem_"打头。线程使用的基本信号量函数有四个。

  - 1、信号量初始化。
    
    int sem_init (sem_t *sem , int pshared, unsigned int value);
    
    这是对由sem指定的信号量进行初始化，设置好它的共享选项(linux 只支持为0，即表示它是当前进程的局部信号量)，然后给它一个初始值VALUE。
  
  - 2、等待信号量。给信号量减1，然后等待直到信号量的值大于0。
   
    int sem_wait(sem_t *sem);
  
  - 3、释放信号量。信号量值加1。并通知其他等待线程。
    
    int sem_post(sem_t *sem);
  
  - 4、销毁信号量。我们用完信号量后都它进行清理。归还占有的一切资源。
    
    int sem_destroy(sem_t *sem);

- 信号量集：
	
  System V IPC要求信号量必须是一个集合,即:信号量集;

  信号量集和信号量一样,都是为了控制多个进程对共享资源的同步访问而引入的同步对象;System V IPC中规定:不能只单独定义一个信号量,而是只能定义一个信号量的集合,即:信号量集,其中包含一组信号量,同一信号量集中的多个信号量使用同一个唯一的ID来引用,这样做的目的是为了对多个共享资源进行同步控制的需要;

  补充资料：
  
  http://www.cnblogs.com/eleclsc/p/5838790.html
  
  http://bdxnote.blog.163.com/blog/static/844423520100502850251/

### 20、Linux线程相关函数
  
  - 创建线程：pthread_create();
  
  - 退出线程：pthread_exit();.
  
  - 等待线程：pthread_join();
  
  - 结束另外一个线程：pthread_cancle();
  
  - 分离线程：pthread_detach(pthread_t thread);

### 21、系统如何将一个信号通知到进程?

- 内核给进程发送信号，是在进程所在的进程表项的信号域设置对应的信号的位。

- 进程检查信号的时机是：进程即将从内核态返回用户态时。如果进程睡眠了，要看睡眠能不能被中断，如果能被中断则唤醒。

- 进程有一个链表的数据结果，维护一个未决信号的链表。

- 信号在进程中注册，其实就是把该信号加入到这个未决信号链表当中。

- 可靠信号不管链表中是否已经有这个信号了，还是会加进去。不可靠信号，如果链表中已经有这个信号了，就会忽略。

- 进程处理信号的时机就是从内核态即将返回用户态度的时候。

- 执行用户自定义的信号处理函数的方法很巧妙。把该函数的地址放在用户栈栈顶，进程从内核返回到用户态的时候，先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态。
被屏蔽的信号，取消屏蔽后还会被检查。

### 22、堆和栈的区别
  
  1、堆大栈小(针对虚拟地址空间)。例如深层次的递归可能造成栈溢出。
  
  2、动态分配内存时要栈要快于堆。栈的分配函数被定义成内联函数，并且栈分配内存时仅仅需要修改栈帧(栈顶指针向下生长)。堆分配内存时涉及维护一个空闲链表(遍历链表找到可用的内存后修改链表返回)，从异步安全角度考虑甚至涉及加锁和解锁。

  3、malloc函数/new运算符分配的内存位于堆上，局部变量和自动变量位于栈上。

  补充问题：为什么栈小堆大？（还是腾讯问我的一个问题，考察了我对知识的思考程度）
  
### 23、锁的种类，如何引起死锁，死锁如何避免（必问！！！）（自旋锁和互斥锁区别）互斥锁的实现原理（屏蔽中断，CAS），读写锁实现

- 锁的种类：
  
  互斥量，自旋锁，读写锁，文件锁.

- 死锁的四个必要条件（四个条件四者不可缺一）：
  
  （1）互斥条件。某段时间内，一个资源一次只能被一个进程访问。
  
  （2）请求和保持条件。进程A已经拥有至少一个资源，此时又去申请其他资源，而该资源又正在被进程使用，此时请求进程阻塞，但对自己已经获得的资源保持不放。
  
  （3）不可抢占资源。进程已获得的资源在未使用完不能被抢占，只能在自己使用完时由自己释放。
  
  （4）循环等待序列。存在一个循环等待序列P0P1P2……Pn，P0请求正在被进程P1占有的资源，P1请求正在被P2占有的资源……Pn正在请求被进程P0占有的资源。

- 死锁的避免算法：
  
  1.忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
  
  2.检测死锁并且恢复。
  
  3.仔细地对资源进行动态分配，以避免死锁。即按照顺序加锁
  
  4.通过破除死锁四个必要条件之一，来防止死锁产生。

### 24、Fwrite、write、fread、read、fopen、open、区别，可移植性哪个好

### 25、虚拟地址空间怎么理解的？其中的栈和堆是什么？
  
### 26、虚拟内存的分布

### 27、Linux下文件读取经过哪些过程，在内核源码中是怎么实现的

### 28、常见进程调度算法

### 29、ELF是什么？其大小与程序中全局变量的是否初始化有什么关系(注意未初始化的数据放在bss段)
  
  （1）可执行文件：包含了代码和数据。具有可执行的程序。
  
  （2）可重定位文件：包含了代码和数据(这些数据是和其他重定位文件和共享的object文件一起连接时使用的)
  
  （3）共享object文件(又可叫做共享库)：包含了代码和数据(这些数据是在连接时候被连接器ld和运行时动态连接器使用的)。使创建共享库容易，使动态装载和共享库的结合更加容易。在ELF下，在C++中，全局的构造函数和析构函数在共享库和静态库中用同样方法处理。

### 30、linux的内存管理机制是什么?
- Linux虚拟内存的实现需要6种机制的支持：

  地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机制和内存共享机制

  内存管理程序通过映射机制把用户程序的逻辑地址映射到物理地址。当用户程序运行时，如果发现程序中要用的虚地址没有对应的物理内存，就发出了请求页要求。如果有空闲的内存可供分配，就请求分配内存(于是用到了内存的分配和回收)，并把正在使用的物理页记录在缓存中(使用了缓存机制)。如果没有足够的内存可供分配，那么就调用交换机制;腾出一部分内存。另外，在地址映射中要通过TLB(翻译后援存储器)来寻找物理页;交换机制中也要用到交换缓存，并且把物理页内容交换到交换文件中，也要修改页表来映射文件地址。

### 31、Linux内存管理策略,
- task_struct -> mm_struct -> vm_area_struct

### 32、Linux文件系统
  - 每一个磁盘分区上有一个文件系统。划分超级块，i节点位图，block位图，i节点数组，block数组。
  
  - 说说i节点上的元数据

### 33、原子操作在计算机内部是如何实现的

### 34、Linux的七个运行级别？

### 35、用户态和内核态的区别？从用户态切换到内核态有哪几种方式。

### 36、常见的页面置换算法?
http://blog.csdn.net/a724888/article/details/70038420

### 37、Linux下swap区作用

### 38、如果进程中断如何恢复

### 39、.缺页操作系统如何处理

### 40、RPC实现

### 41、系统调用和库函数的区别
- 1、系统调用和库函数的关系
系统调用通过软中断int 0x80从用户态进入内核态。函数库中的某些函数调用了系统调用。函数库中的函数可以没有调用系统调用，也可以调用多个系统调用。编程人员可以通过函数库调用系统调用。高级编程也可以直接采用int 0x80进入系统调用，而不必通过函数库作为中介。如果是在核心编程，也可以通过int 0x80进入系统调用，此时不能使用函数库。因为函数库中的函数是内核访问不到的。

- 2、从用户调用库函数到系统调用执行的流程。
	- 假设用户调用ssize_t write (int fields, cont void *buff, size_t nbytes);库函数。
	- 库函数会执行int 0x80中断。因为中断使得进程从用户态进入内核态，所以参数通过寄存器传送。
	- 0x80中断对应的中断例程被称为system call handler。其工作是：
		- 存储大多数寄存器到内核堆栈中。这是汇编代码写的。
		- 执行真正的系统调用函数――system call service routine。这是C代码。
		- 通过ret_from_sys_call ()返回，回到用户态的库函数。这是汇编代码。


- 3、系统调用

系统调用提供的函数如open, close, read, write, ioctl等，需包含头文件unistd.h。以write为例：其函数原型为 size_t write(int fd, const void *buf, size_t nbytes)，其操作对象为文件描述符或文件句柄fd(file descriptor)，要想写一个文件，必须先以可写权限用open系统调用打开一个文件，获得所打开文件的fd，例如 fd=open(/"/dev/video/", O_RDWR)。fd是一个整型值，每新打开一个文件，所获得的fd为当前最大fd加1。


Linux系统默认分配了3个文件描述符值：0-standard input，1-standard output，2-standard error。

  - 系统调用通常用于底层文件访问(low-level file access)，例如在驱动程序中对设备文件的直接访问。
	
  - 系统调用是操作系统相关的，因此一般没有跨操作系统的可移植性。
	
  - 系统调用发生在内核空间，因此如果在用户空间的一般应用程序中使用系统调用来进行文件操作，会有用户空间到内核空间切换的开销。事实上，即使在用户空间使用库函数来对文件进行操作，因为文件总是存在于存储介质上，因此不管是读写操作，都是对硬件(存储器)的操作，都必然会引起系统调用。也就是说，库函数对文件的操作实际上是通过系统调用来实现的。例如C库函数fwrite()就是通过write()系统调用来实现的。
	
  - 这样的话，使用库函数也有系统调用的开销，为什么不直接使用系统调用呢?这是因为，读写文件通常是大量的数据(这种大量是相对于底层驱动的系统调用所实现的数据操作单位而言)，这时，使用库函数就可以大大减少系统调用的次数。这一结果又缘于缓冲区技术。在用户空间和内核空间，对文件操作都使用了缓冲区，例如用fwrite写文件，都是先将内容写到用户空间缓冲区，当用户空间缓冲区满或者写操作结束时，才将用户缓冲区的内容写到内核缓冲区，同样的道理，当内核缓冲区满或写结束时才将内核缓冲区内容写到文件对应的硬件媒介。

- 4、库函数调用

标准C库函数提供的文件操作函数如fopen, fread, fwrite, fclose, fflush, fseek等，需包含头文件stdio.h。以fwrite为例，其函数原型为size_t fwrite(const void *buffer, size_t size, size_t item_num, FILE *pf)，其操作对象为文件指针FILE *pf，要想写一个文件，必须先以可写权限用fopen函数打开一个文件，获得所打开文件的FILE结构指针pf，例如pf=fopen(/"~/proj/filename/", /"w/")。实际上，由于库函数对文件的操作最终是通过系统调用实现的，因此，每打开一个文件所获得的FILE结构指针都有一个内核空间的文件描述符fd与之对应。同样有相应的预定义的FILE指针：stdin-standard input，stdout-standard output，stderr-standard error。

  - 库函数调用通常用于应用程序中对一般文件的访问。
  - 库函数调用是系统无关的，因此可移植性好。
  - 由于库函数调用是基于C库的，因此也就不可能用于内核空间的驱动程序中对设备的操作

### 42、机器大小端判断
- 数据的高字节对应机器的高字节地址，此时是小端机器（大大小小）
- 数据的高字节对应机器的低字节地址，此时是大端机器

网络字节序一般采用大端，机器一般采用小端存储

- 方法一：
```
int main()
{
    int a = 1;
    if (*(char*)&a == 1)
        cout << "小端模式" << endl;
    else
        cout << "大端模式" << endl;
    return 0;
}
```

- 方法二：
```
union Test
{
    int a;
    char b;
};
int main()
{
    Test t;
    t.a = 1;
    if (t.b == 1)
        cout << "小端机器" << endl;
    else
        cout << "大端机器" << endl;
    return 0;
}
```
